On Linux nodes, kubernetes configures IPTables, IPVS or NFTables. Thus it delegates the routing to linux kernel. A `kube-proxy` watches for events on the kube control space and konfigures the host accordingly.
IPTables is the old and trusted method, and it is the default. IPVS requires additional services from the linux host, but is more performant as it works in kernel space. NFTables is a new mechanism in the linux kernel (netfilter). It also operates in kernel space, but it\s support in kubernetes is currently (1.31) in beta.

In kube, a service is essentially a networking definition. This concept is implemented by routing, and not DNS. There are different service types, but we are most interested in types ClusterIP and NodePort. With ClusterIP all addresses and ports are assigned dynamically for ports, pods etc. There is no source NAT.

With NodePort, each serviice is allocated the same port number on every node. This is used when you have a load balancer in front of your cluster and you need to configure the LB with predictable port numbers. However, with NodePort the kube network uses source NAT, replacing the sender's IP address. This can be circumvented by setting the `externalTrafficPolivy` to `Local` in the service settings. However, with this kube can only route the packets to pods that are in the same node.
If in this scenario you have a fixed service, like a traefik proxy, where the packets are processed, this may not be a problem if the servies to which the proxy redirects the traffic use ClusterIPs. This particular scenario may arise if you need to populate the XFF header [[X-Forwarded-For and proxy protocols]].  Note that this is not an issue if your load balancer in front of your kube cluster is operating at L7, in which case it already handles the header for you.